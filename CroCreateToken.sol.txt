//  $$$$$$\                       $$$$$$\                                 $$\
// $$  __$$\                     $$  __$$\                                $$ |
// $$ /  \__| $$$$$$\   $$$$$$\  $$ /  \__| $$$$$$\   $$$$$$\   $$$$$$\ $$$$$$\    $$$$$$\
// $$ |      $$  __$$\ $$  __$$\ $$ |      $$  __$$\ $$  __$$\  \____$$\\_$$  _|  $$  __$$\
// $$ |      $$ |  \__|$$ /  $$ |$$ |      $$ |  \__|$$$$$$$$ | $$$$$$$ | $$ |    $$$$$$$$ |
// $$ |  $$\ $$ |      $$ |  $$ |$$ |  $$\ $$ |      $$   ____|$$  __$$ | $$ |$$\ $$   ____|
// \$$$$$$  |$$ |      \$$$$$$  |\$$$$$$  |$$ |      \$$$$$$$\ \$$$$$$$ | \$$$$  |\$$$$$$$\
//  \______/ \__|       \______/  \______/ \__|       \_______| \_______|  \____/  \_______|

// Web: https://crocreate.app

// Tokenomics
// - Supply: 100,000,000
// - Max Wallet: 2% of total supply

// Transaction Fees
// - Purchase Tax: 0%
// - Sell Tax: 1% (Token Burn)

// Burn Description
// 1% of every sell transaction is sent to the 0x00000â€¦ dead address, reducing the tokens in circulation.

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface ICRC20 {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    function balanceOf(address account) external view returns (uint256);

    function transfer(address to, uint256 value) external returns (bool);

    function allowance(address owner, address spender)
        external
        view
        returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

contract Ownable {
    event devWalletshipTransferred(
        address previousdevWallet,
        address newdevWallet
    );

    address payable public devWallet;

    constructor() {
        devWallet = payable(0xF70eA5817849A968B47Ec21D8DD0706498DF618A);
    }

    modifier onlydevWallet() {
        require(msg.sender == devWallet, "Caller is not the dev wallet");
        _;
    }

    function setdevWallet(address payable wallet) public onlydevWallet {
        require(wallet != address(0));
        setDevWalletAddress(wallet);
    }

    function setDevWalletAddress(address payable newdevWallet) internal {
        emit devWalletshipTransferred(devWallet, newdevWallet);
        devWallet = newdevWallet;
    }

    function renounceDevWallet() public onlydevWallet {
        devWallet = payable(address(0));
    }
}

interface IVVSFactory {
    function createPair(address tokenA, address tokenB)
        external
        returns (address pair);
}

interface IVVSRouter02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;

    function factory() external pure returns (address);

    function WETH() external pure returns (address);
}

contract CroCreate is ICRC20, Ownable {
    string public name = "CroCreate";
    string public symbol = "CROC";
    uint8 public decimals = 18;
    uint256 public totalSupply = 100_000_000 * 10**uint256(decimals);

    uint8 public BurnFee = 1;
    bool public taxEnabled = true;
    bool public maxWalletEnabled = true;
    uint256 public maxWalletSize = (totalSupply * 2) / 100;

    IVVSRouter02 private VVSV2Router;
    address private VVSV2Pair;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) public ExcludedFromFee;
    mapping(address => bool) public excludedFromMaxWallet;

    constructor() {
        balances[devWallet] = totalSupply;
        ExcludedFromFee[devWallet] = true;
        ExcludedFromFee[address(this)] = true;
        excludedFromMaxWallet[devWallet] = true;

        VVSV2Router = IVVSRouter02(0x145863Eb42Cf62847A6Ca784e6416C1682b1b2Ae);
        VVSV2Pair = IVVSFactory(VVSV2Router.factory()).createPair(
            address(this),
            VVSV2Router.WETH()
        );
        excludedFromMaxWallet[VVSV2Pair] = true;

        emit Transfer(address(0), devWallet, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint256) {
        return balances[account];
    }

    function transfer(address recipient, uint256 amount)
        public
        override
        returns (bool)
    {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address _owner, address spender)
        public
        view
        override
        returns (uint256)
    {
        return _allowances[_owner][spender];
    }

    function approve(address spender, uint256 amount)
        public
        override
        returns (bool)
    {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(
            currentAllowance >= amount,
            "CRC20: transfer amount exceeds allowance"
        );
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    function _approve(
        address owner_,
        address spender,
        uint256 amount
    ) private {
        require(owner_ != address(0), "CRC20: approve from the zero address");
        require(spender != address(0), "CRC20: approve to the zero address");
        _allowances[owner_][spender] = amount;
        emit Approval(owner_, spender, amount);
    }

    function ExcludeFromFee(address account) external onlydevWallet {
        ExcludedFromFee[account] = true;
    }

    function IncludeFee(address account) external onlydevWallet {
        ExcludedFromFee[account] = false;
    }

    function ExcludeFromMaxWallet(address account) external onlydevWallet {
        excludedFromMaxWallet[account] = true;
    }

    function IncludeMaxWallet(address account) external onlydevWallet {
        excludedFromMaxWallet[account] = false;
    }

    function DisableTaxesandMaxWallet() external onlydevWallet {
        taxEnabled = false;
        maxWalletEnabled = false;
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal {
        require(amount > 0, "CRC20: transfer amount must be greater than zero");
        require(
            amount <= balances[from],
            "CRC20: transfer amount exceeds balance"
        );

        if (maxWalletEnabled && taxEnabled && !excludedFromMaxWallet[to]) {
            require(
                balances[to] + amount <= maxWalletSize,
                "exceeds max wallet size"
            );
        }

        bool shouldApplyFee = taxEnabled &&
            !ExcludedFromFee[from] &&
            !ExcludedFromFee[to];
        if (to == VVSV2Pair && shouldApplyFee) {
            uint256 burnFeeFeeTax = (amount * BurnFee) / 100;
            uint256 transferAmount = amount - burnFeeFeeTax;

            _transferTokens(from, to, transferAmount);
            _burn(from, burnFeeFeeTax);
        } else {
            _transferTokens(from, to, amount);
        }
    }

    function _transferTokens(
        address sender,
        address recipient,
        uint256 amount
    ) private {
        balances[sender] = balances[sender] - amount;
        balances[recipient] = balances[recipient] + amount;
        emit Transfer(sender, recipient, amount);
    }

    function _burn(address account, uint256 amount) internal {
        require(account != address(0), "CRC20: burn from the zero address");
        require(
            balances[account] >= amount,
            "CRC20: burn amount exceeds balance"
        );
        balances[account] = balances[account] - amount;
        totalSupply = totalSupply - amount;
        emit Transfer(account, address(0), amount);
    }
}